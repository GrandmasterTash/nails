use std::sync::Arc;
use mongodb::Database;
use parking_lot::RwLock;
use chrono::{DateTime, Utc};
use futures::future::{err, ok, Ready};
use actix_http::{Error, error::ErrorBadRequest};
use crate::routes::admin::set_time::TimeProvider;
use super::{config::Configuration, http::http_client, rabbit::Publisher};
use actix_web::{FromRequest, HttpRequest, client::Client, dev, web::Data};

//
// The context is used to pass globals around and share them between HTTP handlers.
// It is composed from multiple levels during the app initialisation: -
//
// RequestContext                << Used in the HTTP handlers. This is the 'goto' context.
//    PartialRequestContext      << Used in the middleware tier.
//        InitialisationContext  << Used during app initialisation.
//
// The PartialRequestContext is created for each worker thread.
// The RequestContext is created for each request.
//

///
/// Used to hold various elements of the context during initialisation. These are all send and are
/// safe to pass between threads - unlike the HTTP Client struct which must be initialised for each
/// worker thread.
///
/// There is one creted during service start-up.
///
pub struct InitialisationContext {
    db: Database,
    publisher: Publisher,
    config: Configuration,
    time_provider: Arc<RwLock<TimeProvider>>
}

impl InitialisationContext {
    pub fn new(db: Database, config: Configuration, publisher: Publisher) -> Self {
        InitialisationContext {
            db,
            config,
            publisher,
            time_provider: Arc::new(RwLock::new(TimeProvider::default()))
        }
    }

    pub fn db(&self) -> &Database {
        &self.db
    }

    pub fn publisher(&self) -> &Publisher {
        &self.publisher
    }

    pub fn now(&self) -> DateTime<Utc> {
        self.time_provider.read().now()
    }

    ///
    /// Set or clear the fixed time - if the request is succsseful returns true.
    ///
    /// It's possible that lock poisoning means this cannot be completed.
    ///
    pub fn set_now(&self, now: Option<DateTime<Utc>>) {
        self.time_provider.write().fix(now);
    }

    pub fn config(&self) -> &Configuration {
        &self.config
    }
}

///
/// This struct contains all the global data commonly used in the vast majority of request handlers.
///
/// There is one per worker thread.
///
/// It is called partial because it doesn't contain the request_id field. Once a request_id is available
/// this struct should be wrapped into a request-specific RequestContext and used for the remainder of
/// the client request.
///
// #[derive(Debug)]
pub struct PartialRequestContext {
    inner: Arc<InitialisationContext>,
    client: Client,
}

impl PartialRequestContext {
    pub fn db(&self) -> &Database {
        &self.inner.db
    }

    pub fn client(&self) -> &Client {
        &self.client
    }

    pub fn publisher(&self) -> &Publisher {
        &self.inner.publisher
    }

    pub fn now(&self) -> DateTime<Utc> {
        self.inner.now()
    }

    pub fn set_now(&self, now: Option<DateTime<Utc>>) {
        self.inner.set_now(now);
    }

    pub fn config(&self) -> &Configuration {
        &self.inner.config
    }
}

///
/// Wrap the InitialisationContext and create a HTTP client to boot.
///
impl From<Arc<InitialisationContext>> for PartialRequestContext {
    fn from(ctx: Arc<InitialisationContext>) -> Self {
        let cfg = ctx.config().clone();
        PartialRequestContext {
            inner: ctx,
            client: http_client(&cfg),
        }
    }
}

///
/// The RequestContext contains all the global data commonly used in the vast majority of request handlers.
///
/// There is one per request.
///
/// This includes the request_id (X-Correlation-Id), database, configuration, message publisher, http
/// client, etc. Keeping these things in a context avoids too many fn parameters being repeated through
/// the codebase.
///
/// A RequestContext is intended to be used at the 'business tier' of code. i.e. One level lower than the
/// 'http tier' and shouldn't include any HTTP related concepts.
///
pub struct RequestContext {
    inner: Arc<PartialRequestContext>,
    request_id: String
}

impl RequestContext {
    ///
    /// Convert the thread's PartialRequestContext and request_id into a request-specific
    /// RequestContext.
    ///
    pub fn from(http_context: Data<PartialRequestContext>, request_id: String) -> Self {
        RequestContext {
            inner: http_context.into_inner(),
            request_id
        }
    }

    ///
    /// A unique id for this specific request. This should be added to all downstream requests
    /// and event notifications.
    ///
    /// The value originates from the incoming x-correlation-id header and is generated by
    /// middleware if not provided.
    ///
    pub fn request_id(&self) -> &str {
        self.request_id.as_ref()
    }

    ///
    /// A MongoDB reference to the underlying database. Used to interract with collections, etc.
    ///
    pub fn db(&self) -> &Database {
        &self.inner.db()
    }

    ///
    /// An instance of a Http client to communicate with downstream services. You can use this
    /// directly, or (preferred), use the helpers in the utils::http module for post, put, get, etc.
    ///
    pub fn client(&self) -> &Client {
        &self.inner.client()
    }

    ///
    /// A communication channel to send messages to RabbitMQ (or whatever notification system is
    /// configured).
    ///
    pub fn publisher(&self) -> &Publisher {
        &self.inner.publisher()
    }

    ///
    /// Return the current Utc timezone time. Tests can alter/fix this value.
    ///
    pub fn now(&self) -> DateTime<Utc> {
        self.inner.now()
    }

    ///
    /// Used to set the TimeProvider's clock to a fixed time (or clear the fixed time).
    ///
    /// This allows tests to use hardcoded times.
    ///
    pub fn set_now(&self, now: Option<DateTime<Utc>>) {
        self.inner.set_now(now);
    }

    ///
    /// The service's static configuration, initially loaded through environment variables and
    /// file secrets.
    ///
    pub fn config(&self) -> &Configuration {
        &self.inner.config()
    }
}

///
/// Allow a RequestContext to be injected into HTTP handler calls.
///
impl FromRequest for RequestContext {
    type Error = Error;
    type Future = Ready<Result<Self, Self::Error>>;
    type Config = ();

    fn from_request(req: &HttpRequest, _payload: &mut dev::Payload) -> Self::Future {
        if let Some(ctx) = req.extensions().get::<RequestContext>() {
            ok(RequestContext { inner: ctx.inner.clone(), request_id: ctx.request_id.clone() } )
        } else {
            err(ErrorBadRequest("request context is missing"))
        }
    }
}

///
/// Allows us to capture the request_id when instrumenting requests.
///
impl std::fmt::Debug for RequestContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.request_id)
    }
}