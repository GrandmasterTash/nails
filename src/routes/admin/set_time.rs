use tracing::info;
use chrono::{DateTime, Utc};
use actix_http::http::StatusCode;
use actix_web::{Responder, web::Path};
use crate::utils::context::RequestContext;

///
/// The TimeProvider::now() should be used in-favour of Utc::now() to get the current DateTime<Utc>.
///
/// Tests can use apis below to fix the time to specific value, this allows data generated by
/// tests to have a deterministic value from datetimes.
///
#[derive(Debug)]
pub struct TimeProvider {
    fixed: Option<DateTime<Utc>>
}

impl TimeProvider {
    pub fn default() -> Self {
        TimeProvider { fixed: None }
    }

    pub fn now(&self) -> DateTime<Utc> {
        match self.fixed {
            Some(fixed) => fixed,
            None => Utc::now()
        }
    }

    pub fn fix(&mut self, fixed: Option<DateTime<Utc>>) {
        self.fixed = fixed;
    }
}

///
/// Set the new time - argument must be in the format '2020-01-01T12:00:00.000Z'
///
pub async fn handle_set(fixed_time: Path<String>, ctx: RequestContext) -> impl Responder {
    let parsed = match DateTime::parse_from_rfc3339(&fixed_time) {
        Ok(parsed) => parsed.with_timezone(&Utc),
        Err(err) => return err.to_string().with_status(StatusCode::BAD_REQUEST),
    };

    ctx.set_now(Some(parsed));
    info!("TimeProvider fixed to {:?}", parsed);
    format!("Time set to {:?}", parsed).with_status(StatusCode::OK)
}

///
/// Restore the clock to normal Utc::now() behavour.
///
pub async fn handle_reset(ctx: RequestContext) -> impl Responder {
    ctx.set_now(None);
    info!("TimeProvider no-longer fixed");
    format!("Time no-longer fixed").with_status(StatusCode::OK)
}